\documentclass[a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.5cm, left=2.5cm, bottom=1.5cm, right=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{tikz}

\author{Théo Verhelst}
\title{Résumé du cours d'Algorithmique et Recherche Opérationelle\\
\emph{INFO-F310}}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
\paragraph{}
Parmi les nombreux domaines compris dans l'algorithmique et la recherche
opérationelle, dans ce cours seront abordés la \emph{programmation mathématique}
et les \emph{méthodes combinatoires dans les graphes}.

\chapter{Programmation mathématique}
\section{Définition de la programmation mathématique}
\paragraph{}
La programmation mathématique est une modélisation de problèmes (qui peuvent
provenir d'une large gamme de domaines) ainsi que leur résolution.
\paragraph{Définition:} Un problème de programmation mathématique est défini
par un tuple \((z, G)\), où
\[z:\mathbb{R}^n\to\mathbb{R}:(x_1,\dots,x_n)\mapsto f(x_1,\dots,x_n)\]
est appelée \emph{fonction économique} (ou encore \emph{fonction de coût}), et
où \[\star\in\{=,\ge,\le\},\;G=\{(g_j(x_1,\dots,x_n)\star b_j)\;\forall j\in[1,m]\}\]
sont appelées \emph{contraintes}.
\paragraph{Notation:}On notera
\[g_j(x_1,\dots,x_n)\begin{Bmatrix}\le\\\ge\\=\end{Bmatrix}b_j\quad\forall j\in[1,m]\]
\paragraph{Définition:}
Résoudre un problème de programmation mathématique consiste à trouver les
valeurs \(x_i\;\,\forall i\in[1,n]\) qui maximisent ou minimisent le plus
possible d'une valeur donnée la fonction économique \(z\),
tout en vérifiant toutes les contraintes \(g_j\).
\paragraph{Définition:}
Pour une solution donnée \((x_1,\dots,x_n)\), on dit qu'une contrainte
d'indice \(j\) est saturée quand:
\[g_j(x_1,\dots,x_n)=b_j\]

\paragraph{Note:}
Cette notion n'est intéressante que pour les contraintes à inégalités, et représente le cas où une ressource est utilisée à son maximum.

\paragraph{Définition:}
Quand les fonctions \(f\) et \(g_j\) sont linéaires en \(x_i\), alors le
problème est appelé problème de programmation linéaire.

\section{Exemples de problèmes de programmation mathématique}
\paragraph{Le problème du sac à dos} Supposons que, dans l'optique d'une
randonnée en montagne, l'on cherche à remplir au mieux un sac à dos avec des
aliments ayant chacun un poids et une valeur énergétique, en sachant que l'on ne
peut pas porter plus de 16 unités de poids:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
 & A & B & C \\
\hline
Énergie & 5 & 4 & 1 \\
\hline
Poids & 4 & 2 & 1 \\
\hline
\end{tabular}
\\
\end{center}
On va représenter le problème comme suit:
\[f(x_A, x_B, x_C) =5x_A + 4x_B + x_C\]
\[4x_A + 2x_B + x_C \le 16\]
où \(x_A,x_B,x_C\) sont le nombre de fois que l'on mettra un objet A, B ou C
respectivement dans le sac.\\
On cherche donc à maximiser \(f\), car il faut maximiser la valeur nutritionelle
totale des aliments dans le sac.\\
C'est un problème de programmation linéaire.
\paragraph{Le problème du voyageur de commerce} Problème bien connu, passons
directement à la modélisation en programmation mathématique:\\
Soit \(n\) villes, posons \(x_{ij} = 1\) si le voyageur va de la ville \(i\) à
la ville \(j\), \(x_{ij} = 0\) sinon.\\
Le cout du trajet entre chaque ville est décrit par la matrice
\([c_{ij}]_{i,j\in[n]^2}\)
Nous cherchons à minimiser la fonction de coût
\[z=\sum_i\sum_j x_{ij}c_{ij}\]
Les contraintes sont les suivantes:
\begin{itemize}
	\item Il faut que chaque ville soit visitée une seule fois:
		\[\sum_i x_{ij} = 1\]
	\item Il faut aussi que le voyageur parte aussi de chaque ville:
		\[\sum_j x_{ij} = 1\]
	\item Mais il faut également que le graphe ainsi formé soit connexe ! Pour
		toute partition de l'ensemble \(V\) des villes en deux sous-ensembles
		\(S\) et \(\bar S\) tels que \(S\cup\bar S=V\) et
		\(S\cap\bar S=\emptyset\), il faut qu'il existe un chemin reliant \(S\)
		et \(\bar S\):
		\[\sum_{s\in S}\sum_{\bar s\in\bar S}x_{s\bar s}\ge 1\]
		pour \(x_{s\bar s}=x_{ij}\) si \(s\) et \(\bar s\) correspondent aux
		villes \(i\) et \(j\) respectivement.\\
\end{itemize}
\emph{Difficulté :} L'énumération de toutes les possibilités de cette dernière
contrainte prends beaucoup, beaucoup de temps. C'est ce qui explique la nature
difficile de ce problème, et qui le rends impossible à résoudre en temps
polynomial.
\paragraph{}On pourrait être tenté de résoudre le problème en énumérant toutes
les solutions possibles, et en prenant la meilleure. On peut trouver facilement
que le nombre de solutions possibles est \(n!\). Pour \(n=52\) (le problème
tel que posé pour visiter tous les états des États-Unis), on a à une vache près
\(10^{69}\) solutions. Leur énumération est simplement impossible, même avec le
plus puissant des ordinateur connus.

\section{Respect d'un nombre paramétrique de contraintes}
On peut étendre la définition de la programmation mathématique en permettant
de ne respecter qu'un nombre \(m'\) de contraintes, avec \(m'<m\).
Pour cela, introduisons \(m\) variables booléennes \(\delta_i\) qui indiqueront
si la contrainte \(i\) est respectée. Introduisons également un très grand nombre \(M\),
qui est beaucoup plus grand que toutes les valeurs que peuvent prendre les variables
et les paramètres. On peut alors réécrire les contraintes comme suit:
\[g_i(x_1,\dots,x_n)-b_i\begin{Bmatrix}\le\\\ge\\=\end{Bmatrix}M(1-\delta_i)\]
et rajouter la contrainte suivante:
\[\sum_{i=1}^{m}\delta_i\ge m'\]
Le problème résultant reste un problème de programmation linéaire si \(f\) et
\(g\) sont des fonctions linéaires.
\section{Classification des problèmes de programmation linéaire}
\begin{tikzpicture}
	\node (n1) at (8,10) {Mixtes - entiers};
	\node (n2) at (6,8)  {Mixtes - booléens};
	\node (n3) at (8,6)  {Booléens};
	\node (n4) at (10,8) {Entiers};
	\node (n5) at (4,6)  {Continus};
	
	\foreach \from/\to in {n2/n1, n4/n1, n5/n2, n3/n2}
		\draw[->] (\from) to (\to);
	\draw[<->] (n3) to (n4);
\end{tikzpicture}
\paragraph{}On peut classer les problèmes de programmation linéaire selon la nature de leur variable. Le sens des flèches dans le schéma indique qu'une méthode permettant de résoudre le problème à la destination de la flèche permet également de résoudre un problème à la base de la flèche. On peut donc en conclure qu'un solveur de problème mixant variables entières et continues permet de résoudre tout type de problème de programmation linéaire.
\paragraph{Note:}Un problème à nombre entiers peut également être résolu par un solveur booléens: on pourrait imaginer convertir tous les variables entières en suites de variables booléennes grâce à la conversion binaire du nombre.
\end{document}
