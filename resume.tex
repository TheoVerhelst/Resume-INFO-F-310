\documentclass[a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[top=1.5cm, left=2.5cm, bottom=1.5cm, right=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{textcomp}
\usepackage{graphicx}
\usepackage{tikz}

\author{Théo Verhelst}
\title{Résumé du cours d'Algorithmique et Recherche Opérationelle\\
\emph{INFO-F310}}

\begin{document}
\maketitle
\tableofcontents

\chapter{Introduction}
\paragraph{}
Parmi les nombreux domaines compris dans l'algorithmique et la recherche
opérationelle, dans ce cours seront abordés la \emph{programmation mathématique}
et les \emph{méthodes combinatoires dans les graphes}.

\chapter{Programmation mathématique}
\section{Définition de la programmation mathématique}
\paragraph{}
La programmation mathématique est une modélisation de problèmes (qui peuvent
provenir d'une large gamme de domaines) ainsi que leur résolution.

\paragraph{Définition:} Un problème de programmation mathématique est défini
par un tuple \((z, G)\), où
\[z:E^n\to E:(x_1,\dots,x_n)\mapsto f(x_1,\dots,x_n)\]
est appelée \emph{fonction économique} (ou encore \emph{fonction de coût}), et
où \[\star\in\{=,\ge,\le\},\;G=\{(g_j(x_1,\dots,x_n)\star b_j)\;\forall j\in[1,m]\}\]
sont appelées \emph{contraintes}.

\paragraph{Notation:}On notera
\[g_j(x_1,\dots,x_n)\begin{Bmatrix}\le\\\ge\\=\end{Bmatrix}b_j\quad\forall j\in[1,m]\]

\paragraph{Définition:}On classe les problèmes selon la nature de l'ensemble \(E\):
\begin{itemize}
	\item \(E=\mathbb{R}\) correspond aux problèmes continus
	\item \(E=\mathbb{R}\) correspond aux problèmes entiers
	\item \(E=\{1,0\}\) correspond aux problèmes booléens
\end{itemize}
Ces classes peuvent être mixées, si \(E\) est l'union de plusieurs de ces sous-ensembles.

\paragraph{Définition:}
Résoudre un problème de programmation mathématique consiste à trouver les
valeurs \((x_1,\dots,x_n)\) qui maximisent ou minimisent le plus
possible d'une valeur donnée la fonction économique \(z\),
tout en vérifiant toutes les contraintes \(g_j\).

\paragraph{Définition:}
Pour une solution donnée \((x_1,\dots,x_n)\), on dit qu'une contrainte
d'indice \(j\) est saturée quand:
\[g_j(x_1,\dots,x_n)=b_j\]
Cette notion n'est intéressante que pour les contraintes à inégalités, et représente le cas où une ressource est utilisée à son maximum.

\paragraph{Définition:}
Quand les fonctions \(f\) et \(g_j\) sont linéaires en \(x_i\), alors le
problème est appelé problème de programmation linéaire.

\section{Problèmes  de programmation linéaire continus}
On commencera par exprimer les problèmes de programmation linéaire continus sous forme matricielle:
\[\begin{cases}
\text{Max } z=cx \quad & z\in\mathbb{R},\,c\in\mathbb{R}^{1\times n},\,
x\in\mathbb{R}^{n\times 1}_+ \\
Ax \le b               & A\in\mathbb{R}^{m\times n},\,
b\in\mathbb{R}^{m\times 1}
\end{cases}\]
où \(x\) est le vecteur de variables, \(c\) est le vecteur de coefficients de
la fonction économique \(z\), \(A\) est la matrices de coefficients des contraintes, et \(b\) est le vecteur de termes indépendants des contraintes.

\paragraph{Note:}On se passe des contraintes en \(\ge\) et \(=\), car on peut toujours reformuler ces contraintes avec d'autres contraintes en \(\le\):
\[a=b\Leftrightarrow a\le b\land -a\le-b\]
\[a\ge b\Leftrightarrow -a\le-b\]

\paragraph{Note:}On ne considère que les  problèmes où les variables \((x_1,\dots,x_n)\) sont non-strictement positives, car ces variables représentent souvent des quantités, et ne peuvent donc pas être négatives. Si toutefois une variable \(x_i,\,i\in[1,n]\) peut être négative, on se ramène dans le cas non-strictement positif en posant
\[x_i=y_i-z_i\]
où \(y_i,z_i\) sont deux nouvelles variables dans \(\mathbb{R}^+\).

\paragraph{Note:}On ne considère que la minimisation de la fonction
économique, car on peut ramener un problème de maximisation en un
problème de minimisation en prenant l'opposé de la fonction économique.

\section{Exemples de problèmes de programmation mathématique}
\paragraph{Le problème du sac à dos} Supposons que, dans l'optique d'une
randonnée en montagne, l'on cherche à remplir au mieux un sac à dos avec des
aliments ayant chacun un poids et une valeur énergétique, en sachant que l'on ne
peut pas porter plus de 16 unités de poids:
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
 & A & B & C \\
\hline
Énergie & 5 & 4 & 1 \\
\hline
Poids & 4 & 2 & 1 \\
\hline
\end{tabular}
\\
\end{center}
On va représenter le problème comme suit:
\[f(x_A, x_B, x_C) =5x_A + 4x_B + x_C\]
\[4x_A + 2x_B + x_C \le 16\]
où \(x_A,x_B,x_C\) sont le nombre de fois que l'on mettra un objet A, B ou C
respectivement dans le sac.\\
On cherche donc à maximiser \(f\), car il faut maximiser la valeur nutritionelle
totale des aliments dans le sac.\\
C'est un problème de programmation linéaire.
\paragraph{Le problème du voyageur de commerce} Problème bien connu, passons
directement à la modélisation en programmation mathématique:\\
Soit \(n\) villes, posons \(x_{ij} = 1\) si le voyageur va de la ville \(i\) à
la ville \(j\), \(x_{ij} = 0\) sinon.\\
Le cout du trajet entre chaque ville est décrit par la matrice
\([c_{ij}]_{i,j\in[n]^2}\)
Nous cherchons à minimiser la fonction de coût
\[z=\sum_i\sum_j x_{ij}c_{ij}\]
Les contraintes sont les suivantes:
\begin{itemize}
	\item Il faut que chaque ville soit visitée une seule fois:
		\[\sum_i x_{ij} = 1\]
	\item Il faut aussi que le voyageur parte aussi de chaque ville:
		\[\sum_j x_{ij} = 1\]
	\item Mais il faut également que le graphe ainsi formé soit connexe ! Pour
		toute partition de l'ensemble \(V\) des villes en deux sous-ensembles
		\(S\) et \(\bar S\) tels que \(S\cup\bar S=V\) et
		\(S\cap\bar S=\emptyset\), il faut qu'il existe un chemin reliant \(S\)
		et \(\bar S\):
		\[\sum_{s\in S}\sum_{\bar s\in\bar S}x_{s\bar s}\ge 1\]
		pour \(x_{s\bar s}=x_{ij}\) si \(s\) et \(\bar s\) correspondent aux
		villes \(i\) et \(j\) respectivement.\\
\end{itemize}
\emph{Difficulté :} L'énumération de toutes les possibilités de cette dernière
contrainte prends beaucoup, beaucoup de temps. C'est ce qui explique la nature
difficile de ce problème, et qui le rends impossible à résoudre en temps
polynomial.

\paragraph{}On pourrait être tenté de résoudre le problème en énumérant toutes
les solutions possibles, et en prenant la meilleure. On peut trouver facilement
que le nombre de solutions possibles est \(n!\). Pour \(n=52\) (le problème
tel que posé pour visiter tous les états des États-Unis), on a à une vache près
\(10^{69}\) solutions. Leur énumération est simplement impossible, même avec le
plus puissant des ordinateur connus.

\section{Respect d'un nombre paramétrique de contraintes}
On peut étendre la définition de la programmation mathématique en permettant
de ne respecter qu'un nombre \(m'\) de contraintes, avec \(m'<m\).
Pour cela, introduisons \(m\) variables booléennes \(\delta_i\) qui indiqueront
si la contrainte \(i\) est respectée. Introduisons également un très grand nombre \(M\),
qui est beaucoup plus grand que toutes les valeurs que peuvent prendre les variables
et les paramètres. On peut alors réécrire les contraintes comme suit:
\[g_i(x_1,\dots,x_n)-b_i\begin{Bmatrix}\le\\\ge\\=\end{Bmatrix}M(1-\delta_i)\]
et rajouter la contrainte suivante:
\[\sum_{i=1}^{m}\delta_i\ge m'\]
Le problème résultant reste un problème de programmation linéaire si \(f\) et
\(g\) sont des fonctions linéaires.

\section{Classification des problèmes de programmation linéaire}
\begin{tikzpicture}
	\node (n1) at (8,10) {Mixtes - entiers};
	\node (n2) at (6,8)  {Mixtes - booléens};
	\node (n3) at (8,6)  {Booléens};
	\node (n4) at (10,8) {Entiers};
	\node (n5) at (4,6)  {Continus};
	
	\foreach \from/\to in {n2/n1, n4/n1, n5/n2, n3/n2}
		\draw[->] (\from) to (\to);
	\draw[<->] (n3) to (n4);
\end{tikzpicture}

\paragraph{}On peut classer les problèmes de programmation linéaire selon la nature de leur variable. Le sens des flèches dans le schéma indique qu'une méthode permettant de résoudre le problème à la destination de la flèche permet également de résoudre un problème à la base de la flèche. On peut donc en conclure qu'un solveur de problème mixant variables entières et continues permet de résoudre tout type de problème de programmation linéaire.

\paragraph{Note:}Un problème à nombre entiers peut également être résolu par un solveur booléens: on pourrait imaginer convertir tous les variables entières en suites de variables booléennes grâce à la représentation binaire du nombre.

\section{Algorithme du simplex}
\subsection{Intuition}
L'algorithme du simplex résout des problèmes de programmation linéaire continus, et peut être facilement imaginé dans le cas d'un problème à deux variables continues \((x,y)\). Représentons dans le plan chacune des contraintes comme des sous-ensembles du plan. L'ensemble des solutions admissibles (qui est l'intersection de toutes ces régions) est alors représenté par un polygone.
\begin{center}\textbf{\textbf{}}
\includegraphics{simplex-xy.png}
\end{center}
On peut prouver que la solution se trouve sur un des sommets du polygone. L'algorithme du simplex démarre sur l'un de ces sommets et passe de sommet en sommet vers la solution optimale, toujours en améliorant la solution courante.
\subsection{Reformulation du problème}
Étant donné un problème continu linéaire
\[\begin{cases}
\text{Max } z=cx \\
Ax \le b \\
x_i\ge0\;\forall i\in[1,n]
\end{cases}\]
On introduit \(m\) nouvelles variables non-strictement positives
\([t_1,\dots,t_m]=t\), et on reformule les contraintes comme suit:
\[Ax+t=b\]
Les variables \(t_j\) sont appelées variables d'écart, et représentent la
quantité de ressource qui est encore disponible pour une contrainte donnée.
On en déduit que quand \(t_j=0\), la contrainte \(j\) est saturée.


\end{document}
